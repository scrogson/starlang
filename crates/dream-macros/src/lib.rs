//! # dream-macros
//!
//! Ergonomic macros for DREAM.
//!
//! This crate provides procedural macros that make working with DREAM
//! more convenient and Elixir-like.
//!
//! # Available Macros
//!
//! ## `#[main]`
//!
//! Entry point macro that sets up both tokio and the DREAM runtime:
//!
//! ```ignore
//! #[dream::main]
//! async fn main(handle: RuntimeHandle) -> Result<(), Box<dyn std::error::Error>> {
//!     // Start your processes here
//!     let pid = handle.spawn(|ctx| async move {
//!         // Process logic
//!     });
//!     Ok(())
//! }
//! ```
//!
//! ## `receive!`
//!
//! Pattern matching on received messages with optional timeout:
//!
//! ```ignore
//! receive! { ctx,
//!     MyMessage::Ping => {
//!         println!("Got ping!");
//!     },
//!     MyMessage::Data(x) => {
//!         println!("Got data: {}", x);
//!     },
//!     after Duration::from_secs(5) => {
//!         println!("Timeout!");
//!     }
//! }
//! ```
//!
//! ## `#[derive(GenServerImpl)]`
//!
//! Derive macro for implementing GenServer boilerplate (future feature).

extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, ItemFn};

/// Derive macro for GenServer implementation helpers.
///
/// This is a placeholder for future functionality. Currently it just
/// generates an empty impl block.
///
/// # Example
///
/// ```ignore
/// use dream_macros::GenServerImpl;
///
/// #[derive(GenServerImpl)]
/// struct MyServer {
///     counter: i64,
/// }
/// ```
#[proc_macro_derive(GenServerImpl, attributes(gen_server))]
pub fn derive_gen_server_impl(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;

    // For now, just generate an empty marker trait impl
    let expanded = quote! {
        impl #name {
            /// Returns the type name (generated by GenServerImpl derive).
            pub fn type_name() -> &'static str {
                stringify!(#name)
            }
        }
    };

    TokenStream::from(expanded)
}

/// Attribute macro for marking async functions as DREAM processes.
///
/// This is a placeholder for future functionality.
///
/// # Example
///
/// ```ignore
/// #[dream_process]
/// async fn my_worker(ctx: Context) {
///     // Process logic
/// }
/// ```
#[proc_macro_attribute]
pub fn dream_process(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // For now, just pass through the item unchanged
    item
}

/// Returns the current process's PID from task-local storage.
///
/// This macro is a convenient shorthand for `dream::current_pid()`.
/// It can be called from within any DREAM process without needing
/// access to the Context.
///
/// # Panics
///
/// Panics if called outside of a DREAM process context.
///
/// # Example
///
/// ```ignore
/// use dream::prelude::*;
///
/// dream::spawn(|_ctx| async move {
///     let my_pid = dream::self_pid!();
///     println!("My PID is {:?}", my_pid);
/// });
/// ```
#[proc_macro]
pub fn self_pid(_input: TokenStream) -> TokenStream {
    quote! {
        ::dream::current_pid()
    }
    .into()
}

/// Entry point macro that sets up both tokio and the DREAM runtime.
///
/// This macro transforms an async main function into a synchronous main that:
/// 1. Starts the tokio runtime
/// 2. Initializes the global DREAM runtime
/// 3. Runs your async function
///
/// After initialization, you can use `dream::spawn`, `dream::handle()`, etc.
/// from anywhere in your code.
///
/// # Example
///
/// ```ignore
/// use dream::prelude::*;
///
/// #[dream::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     // Spawn using the global runtime
///     let pid = dream::spawn(|ctx| async move {
///         println!("Hello from DREAM!");
///     });
///
///     // Or get the handle explicitly
///     let handle = dream::handle();
///
///     // Keep the runtime alive
///     tokio::signal::ctrl_c().await?;
///     Ok(())
/// }
/// ```
#[proc_macro_attribute]
pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);

    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_return = &input.sig.output;
    let fn_vis = &input.vis;
    let fn_attrs = &input.attrs;

    let expanded = quote! {
        #(#fn_attrs)*
        #fn_vis fn #fn_name() #fn_return {
            let rt = ::tokio::runtime::Runtime::new().expect("Failed to create tokio runtime");
            rt.block_on(async {
                // Initialize the global DREAM runtime
                ::dream::init();
                #fn_block
            })
        }
    };

    TokenStream::from(expanded)
}
