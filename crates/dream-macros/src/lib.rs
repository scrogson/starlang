//! # dream-macros
//!
//! Ergonomic macros for DREAM.
//!
//! This crate provides procedural macros that make working with DREAM
//! more convenient and Elixir-like.
//!
//! # Available Macros
//!
//! ## `receive!`
//!
//! Pattern matching on received messages with optional timeout:
//!
//! ```ignore
//! receive! { ctx,
//!     MyMessage::Ping => {
//!         println!("Got ping!");
//!     },
//!     MyMessage::Data(x) => {
//!         println!("Got data: {}", x);
//!     },
//!     after Duration::from_secs(5) => {
//!         println!("Timeout!");
//!     }
//! }
//! ```
//!
//! ## `#[derive(GenServerImpl)]`
//!
//! Derive macro for implementing GenServer boilerplate (future feature).

extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

/// Derive macro for GenServer implementation helpers.
///
/// This is a placeholder for future functionality. Currently it just
/// generates an empty impl block.
///
/// # Example
///
/// ```ignore
/// use dream_macros::GenServerImpl;
///
/// #[derive(GenServerImpl)]
/// struct MyServer {
///     counter: i64,
/// }
/// ```
#[proc_macro_derive(GenServerImpl, attributes(gen_server))]
pub fn derive_gen_server_impl(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;

    // For now, just generate an empty marker trait impl
    let expanded = quote! {
        impl #name {
            /// Returns the type name (generated by GenServerImpl derive).
            pub fn type_name() -> &'static str {
                stringify!(#name)
            }
        }
    };

    TokenStream::from(expanded)
}

/// Attribute macro for marking async functions as DREAM processes.
///
/// This is a placeholder for future functionality.
///
/// # Example
///
/// ```ignore
/// #[dream_process]
/// async fn my_worker(ctx: Context) {
///     // Process logic
/// }
/// ```
#[proc_macro_attribute]
pub fn dream_process(_attr: TokenStream, item: TokenStream) -> TokenStream {
    // For now, just pass through the item unchanged
    item
}
